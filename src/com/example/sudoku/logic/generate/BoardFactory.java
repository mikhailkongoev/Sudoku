package com.example.sudoku.logic.generate;

import com.example.sudoku.logic.FieldSize;
import com.example.sudoku.logic.generate.transformations.*;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;

public class BoardFactory {
    private static final int NUMBERS_OF_TRANSFORMATIONS = 50;

    private FieldSize fieldSize = FieldSize.SMALL;
    private final Random random;

    public FieldSize getFieldSize() {
        return fieldSize;
    }

    public BoardFactory(Random random) {
        this.random = random;
    }

    /**
     * generate a full Sudoku board
     *
     * @return board generated by Sudoku rules
     */
    public int[][] generateBoard() {
        return transformBoardManyTimes(fillTheBoard());
    }


    public void printTheBoard(int[][] board) {
        for (int[] ints : board) {
            for (int j = 0; j < board.length; j++) {
                System.out.print(ints[j] + " ");
            }
            System.out.println();
        }
    }

    private int[][] fillTheBoard() {
        int[] firstLine = generateFirstLine();
        int[][] board = new int[fieldSize.getSize()][fieldSize.getSize()];
        for (int lineIndex = 0; lineIndex < firstLine.length; lineIndex++) {
            board[lineIndex] = moveByShift(firstLine.clone(), lineIndex);
        }

        return board;
    }

    private int[] generateFirstLine() {
        int[] firstLine = new int[fieldSize.getSize()];
        for (int i = 0; i < firstLine.length; i++)
            firstLine[i] = i + 1;
        return shuffleLine(firstLine);
    }

    private int[] shuffleLine(int[] firstLine) {
        List<Integer> box = Arrays.asList(Arrays.stream(firstLine).boxed().toArray(Integer[]::new));
        Collections.shuffle(box);
        for (int i = 0; i < firstLine.length; i++)
            firstLine[i] = box.get(i);
        return firstLine;
    }

    private int[] moveByShift(int[] firstLine, int lineIndex) {
        int shift = getShift(lineIndex);
        while (shift > 0) {
            for (int i = 0; i < firstLine.length - 1; i++) {
                int box = firstLine[i + 1];
                firstLine[i + 1] = firstLine[i];
                firstLine[i] = box;
            }
            shift--;
        }
        return firstLine;
    }

    private int getShift(int lineIndex) {
        final int BLOCK = (int) Math.sqrt(fieldSize.getSize());
        int regionIndex = lineIndex / BLOCK;
        int lineIndexOnRegion = lineIndex % BLOCK;
        return (BLOCK * lineIndexOnRegion) + regionIndex;
    }

    private int[][] transformBoardManyTimes(int[][] board) {
        BoardTransformer[] boardTransformers = new BoardTransformer[NUMBERS_OF_TRANSFORMATIONS];
        for (int i = 0; i < boardTransformers.length; i++) {
            int choiceTransform = random.nextInt(5) + 1;
            switch (choiceTransform) {
                case 1:
                    boardTransformers[i] = new SwapRows(random);
                    break;
                case 2:
                    boardTransformers[i] = new SwapColumns(random);
                    break;
                case 3:
                    boardTransformers[i] = new SwapRegionsHorizontally(random);
                    break;
                case 4:
                    boardTransformers[i] = new SwapRegionsVertically(random);
                    break;
                case 5:
                    boardTransformers[i] = new SwapRowsAndColumns();
                    break;
            }
            boardTransformers[i].transform(board);
        }
        return board;
    }

    public void setFieldSize(FieldSize fieldSize) {
        this.fieldSize = fieldSize;
    }
}




